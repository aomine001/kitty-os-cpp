class Processor {
public:
    uint64_t general_purpose_registers[32] {0};

    std::string gpr_to_string_name(uint64_t reg_idx) {
        return std::format("r{}", reg_idx);
    }

    void debugger()
    {
        while (true) {
            std::string cmd;
            std::cin >> cmd;

            if (cmd == "x") {
                std::cout << "N: " << std::endl;
                size_t c = 0;
                std::cin >> c;

                std::cout << "S: " << std::endl;
                std::string size {};
                std::cin >> size;

                std::cout << "Addr: " << std::endl;
                uint64_t addr {0};
                std::cin >> std::hex >> addr;

                if (size == "q") {
                    for (size_t i = 0; i < c; i++) {
                        std::cout << std::format("[{:16x}] {:016x}\n", addr + (i * 8), membus.ReadQwordBe(addr + (i * 8)));
                    }
                } else if (size == "b") {
                    for (size_t i = 0; i < c; i++) {
                        std::cout << std::format("[{:16x}] {:02x}\n", addr + i, membus.ReadByteBe(addr + (i * 1)));
                    }
                } else if (size == "w") {
                    for (size_t i = 0; i < c; i++) {
                        std::cout << std::format("[{:16x}] {:04x}\n", addr + (i * 2), membus.ReadWordBe(addr + (i * 2)));
                    }
                } else if (size == "d") {
                    for (size_t i = 0; i < c; i++) {
                        std::cout << std::format("[{:16x}] {:8x}\n", addr + (i * 4), membus.ReadWordBe(addr + (i * 4)));
                    }
                }
            }
            else if (cmd == "xi") {
                uint64_t addr {0};
                std::cout << "Addr: " << std::endl;
                std::cin >> std::hex >> addr;

                PrintInstruction(addr);
            }
        }
    }

    Processor(std::uint64_t start_ip, Memory& mem) : ip(start_ip), membus(mem) {
        std::cout << "Starting vector is: " << std::hex << std::setw(16) << start_ip << std::dec << std::endl;
    }

    void Execute() {
        while (true)
        {
            PrintInstruction(ip);
            uint32_t instruction = fetch<uint32_t>(ip);

            std::string s;
            int8_t srj_offset;
            int32_t mrj_offset;
            int64_t frj_offset;

            uint16_t reg_idx;
            uint64_t reg_value;
            uint64_t imm_value;

            uint64_t ama_value;

            switch (instruction) {
                case 0x00: // nop
                    break;
                case 0x01: // short relative jump followed by signed 8-bit offset in the memory.
                    srj_offset = static_cast<int8_t>(fetch<uint8_t>(ip));
                    ip += srj_offset;
                    break;
                case 0x02: // far relative jump followed by signed 64-bit offset in the memory.
                    frj_offset = static_cast<int64_t>(fetch<uint64_t>(ip));
                    ip += frj_offset;
                    break;
                case 0x03: // medium relative jump followed by signed
                    mrj_offset = static_cast<int32_t>(fetch<int32_t>(ip));
                    ip += mrj_offset;
                    break;
                case 0x04: // breakpoint
                    debugger();
                    break;
                case 0x05: // Move 64-bit value to register.
                    reg_idx = fetch<uint16_t>(ip);
                    reg_value = fetch<uint64_t>(ip);
                    general_purpose_registers[reg_idx] = reg_value;
                    break;
                case 0x06: // halt
                    std::cout << "Halted!" << std::endl;
                    return;
                case 0x07: // add reg, int64
                    reg_idx = fetch<uint16_t>(ip);
                    imm_value = fetch<uint64_t>(ip);

                    general_purpose_registers[reg_idx] += imm_value;

                    break;
                case 0x08: // sub reg, int64
                    reg_idx = fetch<uint16_t>(ip);
                    imm_value = fetch<uint64_t>(ip);

                    general_purpose_registers[reg_idx] -= imm_value;

                    break;
                case 0x09: // mul reg, int64
                    reg_idx = fetch<uint16_t>(ip);
                    imm_value = fetch<uint64_t>(ip);

                    general_purpose_registers[reg_idx] *= imm_value;

                    break;
                case 0x0a: // idiv reg, int64
                    reg_idx = fetch<uint16_t>(ip);
                    imm_value = fetch<uint64_t>(ip);

                    if (imm_value == 0)
                    {
                        // throw an exception, for now just return
                        std::cout << "Divison by zero.";
                        return;
                    }

                    general_purpose_registers[reg_idx] /= imm_value;

                    break;
                case 0x0b: // mov mem[abs uint64_t], uint64_t
                    ama_value = fetch<uint64_t>(ip);
                    imm_value = fetch<uint64_t>(ip);

                    membus.WriteQwordBe(ama_value, imm_value);

                    break;
                default:
                    std::cout << "Halted! Invalid instruction at address " << std::hex << std::setw(16) << ip - 4 << std::dec << std::endl;
                    return;
            }
        }
    }

    inline void print_instr(std::uint64_t ip, std::string info) {
        std::cout << "[" << std::hex << std::setw(16) << ip << "]" << std::dec << " " << info << std::endl;
    }

    void PrintInstruction(std::uint64_t ip) {
        uint32_t instruction = fetch<uint32_t>(ip);
        uint16_t reg_idx;     // Declare variables outside switch
        uint64_t reg_value;
        uint64_t imm_value;
        uint64_t ama_value;

        switch (instruction) {
            case 0x00:
                print_instr(ip - 4, "nop");
                break;
            case 0x01:
                print_instr(ip - 5, std::format("jmp short rel {}", fetch<int8_t>(ip)));
                break;
            case 0x02:
                print_instr(ip - 12, std::format("jmp far rel {}", fetch<int64_t>(ip)));
                break;
            case 0x03:
                print_instr(ip - 8, std::format("jmp medium rel {}", fetch<int32_t>(ip)));
                break;
            case 0x04:
                print_instr(ip - 4, "bp");
                break;
            case 0x05:
                reg_idx = fetch<uint16_t>(ip);   // Initialize within case
                reg_value = fetch<uint64_t>(ip); // Initialize within case
                print_instr(ip - 14, std::format("mov r{}, {:x}", reg_idx, reg_value));
                break;
            case 0x06:
                print_instr(ip - 4, "hlt");
                break;
            case 0x07:
                reg_idx = fetch<uint16_t>(ip);
                imm_value = fetch<uint64_t>(ip);
                print_instr(ip - 14, std::format("add r{}, {:x}", reg_idx, imm_value));
                break;
            case 0x08:
                reg_idx = fetch<uint16_t>(ip);
                imm_value = fetch<uint64_t>(ip);
                print_instr(ip - 14, std::format("sub r{}, {:x}", reg_idx, imm_value));
                break;
            case 0x09:
                reg_idx = fetch<uint16_t>(ip);
                imm_value = fetch<uint64_t>(ip);
                print_instr(ip - 14, std::format("mul r{}, {:x}", reg_idx, imm_value));
                break;
            case 0x0a:
                reg_idx = fetch<uint16_t>(ip);
                imm_value = fetch<uint64_t>(ip);
                print_instr(ip - 14, std::format("idiv r{}, {:x}", reg_idx, imm_value));
                break;
            case 0x0b:
                ama_value = fetch<uint64_t>(ip);
                imm_value = fetch<uint64_t>(ip);

                print_instr(ip - 20, std::format("mov [{:x}], {:x}", ama_value, imm_value));

                break;
            default:
                print_instr(ip - 4, std::format("invalid: {:x}", instruction));
                break;
        }
    }

    template <typename T>
    T fetch(std::uint64_t& a) {
        if constexpr (sizeof(T) == 1) {
            a++;
            return static_cast<T>(membus.ReadByteBe(a - 1));
        } else if constexpr (sizeof(T) == 2) {
            a += 2;
            return static_cast<T>(membus.ReadWordBe(a - 2));
        } else if constexpr (sizeof(T) == 4) {
            a += 4;
            return static_cast<T>(membus.ReadDwordBe(a - 4));
        } else if constexpr (sizeof(T) == 8) {
            a += 8;
            return static_cast<T>(membus.ReadQwordBe(a - 8));
        }
    }
private:
    Memory& membus;
    std::uint64_t ip;
};